package com.paragon.responses.spec;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Objects;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

/**
 * A function tool call that is bound to an actual function implementation.
 *
 * <p>This class extends {@link FunctionToolCall} with the ability to invoke the function by
 * deserializing the JSON arguments and calling the function implementation.
 *
 * <p>Instances of this class are typically created via {@link
 * FunctionToolStore#bind(FunctionToolCall)}.
 *
 * @see FunctionToolStore
 * @see FunctionToolCall
 */
public class BoundedFunctionCall extends FunctionToolCall {
  private final @Nullable FunctionTool<Record> function;
  private final @Nullable Class<? extends Record> paramClass;
  private final @Nullable ObjectMapper objectMapper;

  /**
   * Creates a bounded function call.
   *
   * @param arguments A JSON string of the arguments to pass to the function.
   * @param callId The unique ID of the function tool call generated by the model.
   * @param name The name of the function to run.
   * @param id The unique ID of the function tool call.
   * @param status The status of the item.
   * @param function The function implementation to invoke.
   * @param paramClass The class to deserialize parameters into.
   * @param objectMapper The ObjectMapper to use for deserialization.
   */
  public BoundedFunctionCall(
      @NonNull String arguments,
      @NonNull String callId,
      @NonNull String name,
      @Nullable String id,
      @Nullable FunctionToolCallStatus status,
      @Nullable FunctionTool<Record> function,
      @Nullable Class<? extends Record> paramClass,
      @Nullable ObjectMapper objectMapper) {
    super(arguments, callId, name, id, status);
    this.function = function;
    this.paramClass = paramClass;
    this.objectMapper = objectMapper;
  }

  /**
   * Invokes the bound function with the deserialized arguments.
   *
   * <p>The JSON arguments from the API response are deserialized into the parameter class, then the
   * function implementation is called with those parameters.
   *
   * @return the function tool call output
   * @throws JsonProcessingException if the arguments cannot be deserialized
   * @throws IllegalStateException if this call is not bound to a function implementation
   */
  public @NonNull FunctionToolCallOutput call() throws JsonProcessingException {
    if (function == null || paramClass == null || objectMapper == null) {
      throw new IllegalStateException(
          "Cannot call unbound function tool call for function '"
              + name()
              + "'. "
              + "Use FunctionToolStore.bind() to create a callable BoundedFunctionCall.");
    }
    Record params = objectMapper.readValue(arguments(), paramClass);
    FunctionToolCallOutput result = function.call(params);
    return Objects.requireNonNullElseGet(
        result, () -> FunctionToolCallOutput.success(callId(), "Function executed successfully"));
  }

  /**
   * Checks if this function call is bound to an implementation.
   *
   * @return true if this call can be invoked
   */
  public boolean isBound() {
    return function != null && paramClass != null && objectMapper != null;
  }

  /**
   * Returns the function implementation, if bound.
   *
   * @return the function implementation, or null if not bound
   */
  public @Nullable FunctionTool<Record> getFunction() {
    return function;
  }
}
